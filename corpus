#!/usr/bin/env zsh
# corpus - Corpus Knowledge Management System
# Version 2.1.0 (Production)

# 确保基本命令可用
export PATH="/usr/bin:/bin:/usr/sbin:/sbin:/usr/local/bin:/opt/homebrew/bin:${PATH}"

set -eu

# -----------------------
# Environment Setup
# -----------------------
CORPUS_DIR="${CORPUS_DIR:-}"

if [[ -z "$CORPUS_DIR" ]]; then
    SCRIPT_PATH="${0:A}"
    SCRIPT_DIR="${SCRIPT_PATH:h}"
    
    if [[ -f "$SCRIPT_DIR/.corpus_root" ]]; then
        CORPUS_DIR="$(<"$SCRIPT_DIR/.corpus_root")"
    elif [[ -d "$SCRIPT_DIR/_template" ]]; then
        CORPUS_DIR="$SCRIPT_DIR"
    else
        echo "Error: CORPUS_DIR not set and cannot auto-detect" >&2
        echo "Please set: export CORPUS_DIR=/path/to/corpus" >&2
        exit 1
    fi
fi

export CORPUS_DIR

if [[ ! -d "$CORPUS_DIR" ]]; then
    echo "Error: Corpus directory does not exist: $CORPUS_DIR" >&2
    exit 1
fi

# -----------------------
# Configuration
# -----------------------
CORPUS_DEFAULT_STATUS="${CORPUS_DEFAULT_STATUS:-probe}"
CORPUS_DEFAULT_EDITOR="${CORPUS_DEFAULT_EDITOR:-nvim}"

# Smart BibTeX file detection
if [[ -z "${ZOTERO_BIB_FILE:-}" ]]; then
    local potential_paths=(
        "/Users/oQ/3_resources/research/refs/zotero.bib"
        "$HOME/3_resources/research/refs/zotero.bib"
        "$HOME/Zotero/library.bib"
    )
    
    ZOTERO_BIB_FILE=""
    for path in "${potential_paths[@]}"; do
        if [[ -f "$path" ]]; then
            ZOTERO_BIB_FILE="$path"
            break
        fi
    done
fi

# UI Colors
readonly UI_RED='\033[31m'
readonly UI_GREEN='\033[32m'
readonly UI_YELLOW='\033[33m'
readonly UI_CYAN='\033[36m'
readonly UI_RESET='\033[0m'
readonly UI_BOLD='\033[1m'

# Layer System Data
readonly CORPUS_LAYERS_DATA='
autopsia|incisio|inc|000_autopsia/010_incisio|Observational cuts and incisions|false|true
autopsia|pathologia|pat|000_autopsia/020_pathologia|Diagnostic analysis of problems|false|true
autopsia|satura|sat|000_autopsia/030_satura|Corrective suturing and healing|false|true
ingesta|fragmenta|frag|100_ingesta/110_fragmenta|Thought fragments and ideas|true|true
ingesta|reliquia|rel|100_ingesta/120_reliquia|Academic references and remnants|true|true
ingesta|impressio|imp|100_ingesta/130_impressio|Sensory impressions and experiences|true|true
ingesta|organon|org|100_ingesta/140_organon|Tools and methodologies|true|true
ingesta|toxicon|tox|100_ingesta/150_toxicon|Toxic or problematic thoughts|true|true
neoplasma|cor|cor|200_neoplasma/210_cor|Core ontological structures|true|true
neoplasma|vascula|vas|200_neoplasma/220_vascula|Connections and networks|true|false
neoplasma|abyssus|aby|200_neoplasma/230_oblivium/231_abyssus|Abyssal depths and unknowns|true|true
neoplasma|nodus|nod|200_neoplasma/230_oblivium/232_nodus|Complex knots and tangles|true|true
neoplasma|hallucina|hal|200_neoplasma/230_oblivium/233_hallucina|Projections and illusions|true|true
neoplasma|fluxus|flu|200_neoplasma/230_oblivium/234_fluxus|Emotional currents and flows|true|true
neoplasma|fractura|fra|200_neoplasma/230_oblivium/235_fractura|Breaks and measurements|true|true
neoplasma|chimera|chi|200_neoplasma/230_oblivium/236_chimera|Hybrid models and constructs|true|true
neoplasma|eruptio|eru|200_neoplasma/240_eruptio|Sudden emergences and insights|true|true
putredo|miasma|mia|300_putredo/310_miasma|Daily toxins and pollutants|true|true
putredo|ulcus|ulc|300_putredo/320_ulcus|Project ulcerations and problems|true|false
putredo|exhumatio|exh|300_putredo/330_exhumatio|Archaeological excavations|true|true
special|delirium|del|400_delirium|Extraordinary and wondrous|true|true
special|vigil|vig|500_vigil|Night watches and endurance|true|true
'

# -----------------------
# UI Functions
# -----------------------
corpus_success() {
    echo -e "${UI_GREEN}${UI_BOLD}[Corpus]${UI_RESET} $1"
}

corpus_info() {
    echo -e "${UI_CYAN}${UI_BOLD}[Corpus]${UI_RESET} $1"
}

corpus_warning() {
    echo -e "${UI_YELLOW}${UI_BOLD}[Corpus]${UI_RESET} ${UI_YELLOW}$1${UI_RESET}" >&2
}

corpus_error() {
    echo -e "${UI_RED}${UI_BOLD}[Corpus]${UI_RESET} ${UI_RED}$1${UI_RESET}" >&2
}

corpus_debug() {
    if [[ "${CORPUS_DEBUG:-}" == "true" ]]; then
        echo -e "\033[90m[DEBUG]\033[0m $1" >&2
    fi
}

# -----------------------
# Utility Functions
# -----------------------
corpus_timestamp() {
    if [[ -x "/bin/date" ]]; then
        /bin/date +%Y%m%d%H%M%S
    elif [[ -x "/usr/bin/date" ]]; then
        /usr/bin/date +%Y%m%d%H%M%S
    else
        printf '%(%Y%m%d%H%M%S)T' -1
    fi
}

corpus_date() {
    if [[ -x "/bin/date" ]]; then
        /bin/date +%Y-%m-%d
    elif [[ -x "/usr/bin/date" ]]; then
        /usr/bin/date +%Y-%m-%d
    else
        printf '%(%Y-%m-%d)T' -1
    fi
}

corpus_safe_filename() {
    local input="$1"
    local safe="${input// /_}"
    safe="${safe//[^a-zA-Z0-9\u4e00-\u9fff_-]/_}"
    safe="${safe//__*/_}"
    safe="${safe#_}"
    safe="${safe%_}"
    [[ -z "$safe" ]] && safe="unnamed"
    echo "$safe"
}

corpus_generate_filename() {
    local layer="$1"
    local content="${2:-}"
    local template_type="${3:-}"
    local timestamp="$(corpus_timestamp)"
    
    # Check if this layer should include dates
    local include_date="true"  # default to true for backward compatibility
    if corpus_layer_exists "$layer"; then
        include_date="$(corpus_find_layer "$layer" "include_date")"
        
        # Special case for reliquia paper template
        if [[ "$layer" == "rel" && "$template_type" == "paper" ]]; then
            include_date="false"
        fi
    fi
    
    if [[ -n "$content" ]]; then
        local safe_content="$(corpus_safe_filename "$content")"
        if [[ "$include_date" == "true" ]]; then
            echo "${layer}_${safe_content}_${timestamp}.md"
        else
            echo "${layer}_${safe_content}.md"
        fi
    else
        if [[ "$include_date" == "true" ]]; then
            echo "${layer}_${timestamp}.md"
        else
            echo "${layer}.md"
        fi
    fi
}

corpus_ensure_directory() {
    local dir="$1"
    
    if [[ -z "$dir" ]]; then
        corpus_error "Directory path cannot be empty"
        return 1
    fi
    
    dir="${dir//\/\//\/}"
    dir="${dir//\\\//\/}"
    dir="${dir%/}"
    
    if [[ ! -d "$dir" ]]; then
        if ! /bin/mkdir -p "$dir"; then
            corpus_error "Cannot create directory: $dir"
            return 1
        fi
    fi
    
    return 0
}

# -----------------------
# Layer System Functions
# -----------------------
corpus_find_layer() {
    local search_layer="$1"
    local field="${2:-all}"
    
    while IFS='|' read -r category full_name alias path description requires_arg include_date; do
        [[ -z "$category" ]] && continue
        
        if [[ "$full_name" == "$search_layer" || "$alias" == "$search_layer" ]]; then
            case "$field" in
                "path") echo "$path" ;;
                "description") echo "$description" ;;
                "requires_arg") echo "$requires_arg" ;;
                "include_date") echo "$include_date" ;;
                "alias") echo "$alias" ;;
                "full_name") echo "$full_name" ;;
                "category") echo "$category" ;;
                "all") echo "$category|$full_name|$alias|$path|$description|$requires_arg|$include_date" ;;
            esac
            return 0
        fi
    done <<< "$CORPUS_LAYERS_DATA"
    
    return 1
}

corpus_layer_exists() {
    corpus_find_layer "$1" "alias" >/dev/null 2>&1
}

corpus_get_layer_path() {
    corpus_find_layer "$1" "path"
}

corpus_layer_requires_arg() {
    local requires_arg="$(corpus_find_layer "$1" "requires_arg")"
    [[ "$requires_arg" == "true" ]]
}

corpus_layer_include_date() {
    local include_date="$(corpus_find_layer "$1" "include_date")"
    [[ "$include_date" == "true" ]]
}

corpus_normalize_layer() {
    corpus_find_layer "$1" "alias"
}

corpus_get_layer_suggestions() {
    local partial="$1"
    
    while IFS='|' read -r category full_name alias path description requires_arg include_date; do
        [[ -z "$category" ]] && continue
        
        if [[ "$full_name" == "$partial"* || "$alias" == "$partial"* ]]; then
            echo "$alias"
        fi
    done <<< "$CORPUS_LAYERS_DATA"
}

# -----------------------
# Citation Processing
# -----------------------
corpus_is_citation() {
    [[ "$1" =~ ^@[a-zA-Z0-9_-]+.*$ ]]
}

corpus_extract_citation_key() {
    local input="$1"
    if [[ "$input" =~ ^@(.+)$ ]]; then
        echo "${match[1]}"
    else
        echo "$input"
    fi
}

# -----------------------
# Template Processing
# -----------------------
corpus_expand_template() {
    local template_file="$1"
    local output_file="$2"
    shift 2
    
    if [[ ! -f "$template_file" ]]; then
        corpus_error "Template not found: $template_file"
        return 1
    fi
    
    local content="$(<"$template_file")"
    
    while [[ $# -ge 2 ]]; do
        local placeholder="$1"
        local replacement="$2"
        shift 2
        content="${content//\{\{${placeholder}\}\}/${replacement}}"
    done
    
    content="${content//\{\{date\}\}/$(corpus_date)}"
    content="${content//\{\{timestamp\}\}/$(corpus_timestamp)}"
    
    if ! echo "$content" > "$output_file"; then
        corpus_error "Failed to write to: $output_file"
        return 1
    fi
    
    return 0
}

# -----------------------
# Option Processing
# -----------------------
corpus_parse_options() {
    unset ${(M)${(k)parameters}:#ARG_*} 2>/dev/null || true
    
    for arg in "$@"; do
        if [[ "$arg" =~ ^--([^=]+)=(.*)$ ]]; then
            local key="${match[1]//-/_}"
            local value="${match[2]}"
            export "ARG_${key}=${value}"
        elif [[ "$arg" =~ ^--(.+)$ ]]; then
            local key="${match[1]//-/_}"
            export "ARG_${key}=true"
        fi
    done
}

# -----------------------
# Editor Integration
# -----------------------
corpus_open_editor() {
    local file="$1"
    
    if [[ ! -f "$file" ]]; then
        corpus_error "File does not exist: $file"
        return 1
    fi
    
    local editor_paths=(
        "/opt/homebrew/bin/nvim"
    )
    
    for path in "${editor_paths[@]}"; do
        if [[ -x "$path" ]]; then
            "$path"
            return 0
        fi
    done
    
    corpus_warning "No suitable editor found. File created at: $file"
    return 1
}

# -----------------------
# Core Commands
# -----------------------
corpus_navigate() {
    builtin cd "$CORPUS_DIR"
    corpus_success "Navigated to Corpus directory"
}

corpus_version() {
    echo "Corpus Knowledge Management System"
    echo "Version: 2.1.0 (Production)"
    echo "Path: $CORPUS_DIR"
    
    local checks=""
    [[ -d "$CORPUS_DIR/_template" ]] && checks+="Template:✓ " || checks+="Template:✗ "
    [[ -d "$CORPUS_DIR/_scripts" ]] && checks+="Scripts:✓ " || checks+="Scripts:✗ "
    [[ -f "$ZOTERO_BIB_FILE" ]] && checks+="Zotero:✓" || checks+="Zotero:✗"
    
    echo "Status: $checks"
}

corpus_list_layers() {
    echo "Available Layers:"
    echo
    
    local category_titles=(
        "autopsia|Autopsia (Self-Analysis):"
        "ingesta|Ingesta (Knowledge Intake):"
        "neoplasma|Neoplasma (Growth & Proliferation):"
        "putredo|Putredo (Decay & Maintenance):"
        "special|Special:"
    )
    
    for category_line in "${category_titles[@]}"; do
        local cat_key="${category_line%%|*}"
        local cat_title="${category_line#*|}"
        
        echo "$cat_title"
        
        while IFS='|' read -r category full_name alias path description requires_arg include_date; do
            [[ -z "$category" || "$category" != "$cat_key" ]] && continue
            
            local display_name
            if [[ "$full_name" == "$alias" ]]; then
                display_name="$alias"
            else
                display_name="$full_name, $alias"
            fi
            
            local content_req=""
            [[ "$requires_arg" == "true" ]] && content_req=" [requires content]"
            
            local date_info=""
            [[ "$include_date" == "false" ]] && date_info=" [no date]"
            
            printf "  %-20s - %s%s%s\n" "$display_name" "$description" "$content_req" "$date_info"
            
        done <<< "$CORPUS_LAYERS_DATA"
        
        echo
    done
}

corpus_help() {
    local command="${1:-}"
    
    if [[ -z "$command" ]]; then
        cat << 'EOF'
Corpus - Pathological Knowledge Management System

USAGE:
    corpus <command> [arguments] [options]

COMMANDS:
    create <layer> [content]    Create a new entry in the specified layer
    nav, cd                     Navigate to Corpus directory
    layers, list                List all available layers
    help [command]              Show help information
    version                     Show version and system status

OPTIONS:
    --status=<status>           Set entry status (probe, draft, evergreen, canon)
    --no-edit                   Don't open editor after creation
    --type=paper               Use paper template (for reliquia layer)

EXAMPLES:
    corpus create frag "new idea about consciousness"
    corpus create rel @pi2022 --type=paper
    corpus create inc --status=draft --no-edit
    corpus nav

For layer details: corpus layers
EOF
    fi
}

# -----------------------
# Creation Commands
# -----------------------
corpus_create() {
    local layer="$1"
    local content=""
    shift
    
    local remaining_args=()
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --*)
                remaining_args+=("$1")
                ;;
            *)
                if [[ -z "$content" ]]; then
                    content="$1"
                else
                    remaining_args+=("$1")
                fi
                ;;
        esac
        shift
    done
    
    corpus_parse_options "${remaining_args[@]}"
    
    if [[ -z "$layer" ]]; then
        corpus_error "Layer must be specified"
        corpus_list_layers
        return 1
    fi
    
    if ! corpus_layer_exists "$layer"; then
        corpus_error "Unknown layer: $layer"
        local suggestions=($(corpus_get_layer_suggestions "$layer"))
        if [[ ${#suggestions[@]} -gt 0 ]]; then
            echo "Suggestions: ${(j:, :)suggestions}" >&2
        fi
        return 1
    fi
    
    local normalized_layer="$(corpus_normalize_layer "$layer")"
    
    if corpus_layer_requires_arg "$normalized_layer" && [[ -z "$content" ]]; then
        corpus_error "Layer '$layer' requires content argument"
        return 1
    fi
    
    local layer_path="$(corpus_get_layer_path "$normalized_layer")"
    local target_dir="$CORPUS_DIR/$layer_path"
    
    if ! corpus_ensure_directory "$target_dir"; then
        return 1
    fi
    
    if [[ "$normalized_layer" == "rel" && -n "$content" ]] && corpus_is_citation "$content"; then
        corpus_create_reliquia_citation "$normalized_layer" "$content" "$target_dir"
        return $?
    fi
    
    corpus_create_standard_entry "$normalized_layer" "$content" "$target_dir"
}

corpus_create_standard_entry() {
    local layer="$1"
    local content="$2"
    local target_dir="$3"
    
    local template_type=""
    if [[ "$layer" == "rel" && "${ARG_type:-}" == "paper" ]]; then
        template_type="paper"
    fi
    
    local filename="$(corpus_generate_filename "$layer" "$content" "$template_type")"
    local file_path="$target_dir/$filename"
    
    local template_file="$CORPUS_DIR/_template/tp_${layer}.md"
    if [[ "$template_type" == "paper" ]]; then
        template_file="$CORPUS_DIR/_template/tp_rel_paper.md"
    fi
    
    if [[ ! -f "$template_file" ]]; then
        corpus_error "Template not found: $template_file"
        return 1
    fi
    
    local entry_status="${ARG_status:-${CORPUS_DEFAULT_STATUS}}"
    local layer_path="$(corpus_get_layer_path "$layer")"
    
    if ! corpus_expand_template "$template_file" "$file_path" \
        "layer" "$layer_path" \
        "status" "$entry_status" \
        "title" "$content"; then
        return 1
    fi
    
    corpus_success "Created $layer entry: $filename"
    
    if [[ "${ARG_no_edit:-}" != "true" ]]; then
        corpus_open_editor "$file_path"
    fi
    
    return 0
}

# -----------------------
# Reliquia (Citation) Processing
# -----------------------
corpus_create_reliquia_citation() {
    local layer="$1"
    local citation_input="$2"  # @pi2022
    local target_dir="$3"
    
    local citation_key="$(corpus_extract_citation_key "$citation_input")"
    
    # Try BibTeX extraction
    local bibtex_script="$CORPUS_DIR/_scripts/parse_bibtex.py"
    local metadata=""
    
    # Find Python
    local python_cmd=""
    local python_locations=(
        "/usr/bin/python3"
        "/Library/Frameworks/Python.framework/Versions/3.9/bin/python3"
        "/Library/Frameworks/Python.framework/Versions/3.11/bin/python3"
        "/opt/homebrew/bin/python3"
    )
    
    for location in "${python_locations[@]}"; do
        if [[ -x "$location" ]]; then
            python_cmd="$location"
            break
        fi
    done
    
    # Attempt BibTeX extraction
    if [[ -n "$python_cmd" && -f "$bibtex_script" && -f "$ZOTERO_BIB_FILE" ]]; then
        if metadata="$("$python_cmd" "$bibtex_script" "$ZOTERO_BIB_FILE" "$citation_key" 2>/dev/null)" && [[ -n "$metadata" ]]; then
            corpus_create_reliquia_with_metadata "$layer" "$citation_input" "$target_dir" "$metadata"
            return $?
        fi
    fi
    
    # Fallback to basic template
    corpus_create_reliquia_fallback "$layer" "$citation_input" "$target_dir"
}

corpus_create_reliquia_with_metadata() {
    local layer="$1"
    local citation_input="$2"
    local target_dir="$3"
    local metadata="$4"
    
    local title="" author="" year="" journal="" doi=""
    
    # Parse metadata
    while IFS='=' read -r key value; do
        case "$key" in
            "title") title="$value" ;;
            "author") author="$value" ;;
            "year") year="$value" ;;
            "journal") journal="$value" ;;
            "doi") doi="$value" ;;
        esac
    done <<< "$metadata"

    local citation_key="$(corpus_extract_citation_key "$citation_input")"
    local filename="$(corpus_generate_filename "$layer" "$citation_input" "paper")"
    local file_path="$target_dir/$filename"
    local template_file="$CORPUS_DIR/_template/tp_rel_paper.md"
    
    if ! corpus_expand_template "$template_file" "$file_path" \
        "layer" "$(corpus_get_layer_path "$layer")" \
        "status" "${ARG_status:-${CORPUS_DEFAULT_STATUS}}" \
        "citation_key" "$citation_input" \
        "title" "$title" \
        "author" "$author" \
        "year" "$year" \
        "journal" "$journal" \
        "doi" "$doi"; then
        return 1
    fi
    
    corpus_success "Created reliquia paper with metadata: $filename"
    corpus_info "Paper: $title ($year)"
    
    if [[ "${ARG_no_edit:-}" != "true" ]]; then
        corpus_open_editor "$file_path"
    fi
    
    return 0
}

corpus_create_reliquia_fallback() {
    local layer="$1"
    local citation_input="$2"
    local target_dir="$3"
    
    local citation_key="$(corpus_extract_citation_key "$citation_input")"
    local filename="$(corpus_generate_filename "$layer" "$citation_key" "paper")"
    local file_path="$target_dir/$filename"
    local template_file="$CORPUS_DIR/_template/tp_rel_paper.md"
    
    if ! corpus_expand_template "$template_file" "$file_path" \
        "layer" "$(corpus_get_layer_path "$layer")" \
        "status" "${ARG_status:-${CORPUS_DEFAULT_STATUS}}" \
        "citation_key" "$citation_input" \
        "title" "" \
        "author" "" \
        "year" "" \
        "journal" "" \
        "doi" ""; then
        return 1
    fi
    
    corpus_success "Created reliquia paper entry: $filename"
    
    if [[ "${ARG_no_edit:-}" != "true" ]]; then
        corpus_open_editor "$file_path"
    fi
    
    return 0
}

# -----------------------
# Main Entry Point
# -----------------------
main() {
    local command="${1:-}"
    
    if [[ $# -gt 0 ]]; then
        shift
    fi
    
    case "$command" in
        cd|nav|navigate)
            corpus_navigate
            ;;
        create|new)
            corpus_create "$@"
            ;;
        help|--help|-h)
            corpus_help "$@"
            ;;
        version|--version)
            corpus_version
            ;;
        layers|list)
            corpus_list_layers
            ;;
        debug)
            export CORPUS_DEBUG=true
            corpus_version
            ;;
        *)
            if [[ -n "$command" ]]; then
                corpus_error "Unknown command: $command"
            fi
            corpus_help
            [[ -n "$command" ]] && exit 1
            ;;
    esac
}

main "$@"

